Метод call() вызывает функцию с заданным контекстом. Иначе говоря, вы привязываете функцию к объекту, как если бы она ему принадлежала.

```JavaScript
fun.call(thisArg[, arg1[, arg2[, ...]]])
```

Метод apply() аналогичен call(). Отличие лишь в том, что call() принимает список аргументов, а apply() — массив.

```JavaScript
fun.apply(thisArg, [argsArray])
```

Принцип действия метода bind() напоминает call() и apply(), но в отличие от них он возвращает функцию, выполнение которой может быть отложено. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

```JavaScript
fun.bind(thisArg[, arg1[, arg2[, ...]]])
```

Метод bind() создаёт новую "привязанную функцию" (ПФ). ПФ - это "необычный функциональный объект" ( термин из ECMAScript 6 ), который является обёрткой над исходным функциональным объектом. Вызов ПФ приводит к исполнению кода обёрнутой функции.

ПФ имеет следующие внутренние ( скрытые ) свойства:

- [[BoundTargetFunction]] - оборачиваемый (целевой ) функциональный объект
- [[BoundThis]] - значение, которое всегда передаётся в качестве значения this при вызове обёрнутой функции.
- [[BoundArguments]] - список значений, элементы которого используются в качестве первого аргумента при вызове оборачиваемой функции.
- [[Call]] - внутренний метод. Выполняет код (функциональное выражение), связанный с функциональным объектом.
  Когда ПФ вызывается, исполняется её внутренний метод [[Call]] со следующими аргументами Call(target, boundThis, args).

- target - [[BoundTargetFunction]];
- boundThis - [[BoundThis]];
- args - [[BoundArguments]].

Привязанная функция также может быть сконструирована с помощью оператора new: это работает так, как если бы вместо неё конструировалась целевая функция. Предоставляемое значение this в этом случае игнорируется, хотя ведущие аргументы всё ещё передаются в эмулируемую функцию.
